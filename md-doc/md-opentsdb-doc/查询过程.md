---
typora-copy-images-to: opentsdb-source-analysis-image
---

# 1. 编译安装

本章介绍OpenTsdb的源码编译和安装方式。

## 1.1 源码下载

进入网站https://github.com/OpenTSDB/opentsdb，切换到如下版本，点击Download Zip，下载源码包

![1534261097431](opentsdb-source-analysis-image\1534261097431.png)       ![1534260859328](opentsdb-source-analysis-image\1534260859328.png)                                                           

​              图1.1  版本选择                                                               图1.2 下载ZIP包

将下载的源码解压到指定目录，比如/data1/zhangwusheng/ctyun/opentsdb-2.4.0RC2，以后均以$OPENTSDB_HOME代指此目录。

解压后的目录结构如下图所示：

![1534261585406](opentsdb-source-analysis-image\1534261585406.png)

设置环境变量如下：

export OPENTSDB_HOME=/data1/zhangwusheng/ctyun/opentsdb-2.4.0RC2

## 1.2 源码编译

OpenTsdb采用了Makefile编译安装的形式。

cd $ OPENTSDB_HOME

./build.sh





# 查询过程

1.入口函数



net.opentsdb.tsd.QueryRpc

```java
private void handleQuery(final TSDB tsdb, final HttpQuery query, 
    final boolean allow_expressions) {
         
```
allow_expressions参数只有在/api/query/gexp这个endpoint中才会是true，在普通查询中是false。



首先把HttpQuery对象转换为TSQuery对象，HttpQuery对象是请求参数，TSQuery对象理解为解析后的参数对象
```
public static TSQuery parseQuery(final TSDB tsdb, final HttpQuery query,
    final List<ExpressionTree> expressions) {
  final TSQuery data_query = new TSQuery();
  
  data_query.setStart(query.getRequiredQueryStringParam("start"));
  data_query.setEnd(query.getQueryStringParam("end"));
  
  if (query.hasQueryStringParam("padding")) {
    data_query.setPadding(true);
  }
  
  if (query.hasQueryStringParam("no_annotations")) {
    data_query.setNoAnnotations(true);
  }
  
  if (query.hasQueryStringParam("global_annotations")) {
    data_query.setGlobalAnnotations(true);
  }
  
  if (query.hasQueryStringParam("show_tsuids")) {
    data_query.setShowTSUIDs(true);
  }
  
  if (query.hasQueryStringParam("ms")) {
    data_query.setMsResolution(true);
  }
  
  if (query.hasQueryStringParam("show_query")) {
    data_query.setShowQuery(true);
  }  
  
  if (query.hasQueryStringParam("show_stats")) {
    data_query.setShowStats(true);
  }    
  
  if (query.hasQueryStringParam("show_summary")) {
      data_query.setShowSummary(true);
  }
  
  // handle tsuid queries first
  if (query.hasQueryStringParam("tsuid")) {
    final List<String> tsuids = query.getQueryStringParams("tsuid");     
    for (String q : tsuids) {
      parseTsuidTypeSubQuery(q, data_query);
    }
  }
  
  if (query.hasQueryStringParam("m")) {
    final List<String> legacy_queries = query.getQueryStringParams("m");      
    for (String q : legacy_queries) {
      parseMTypeSubQuery(q, data_query);
    }
  }
  
  // TODO - testing out the graphite style expressions here with the "exp" 
  // param that could stand for experimental or expression ;)
  //传过来的只有在/api/query/gexp或者/api/query才不会为空。
  if (expressions != null) {
    if (query.hasQueryStringParam("exp")) {
      final List<String> uri_expressions = query.getQueryStringParams("exp");
      final List<String> metric_queries = new ArrayList<String>(
          uri_expressions.size());
      // parse the expressions into their trees. If one or more expressions 
      // are improper then it will toss an exception up
      expressions.addAll(Expressions.parseExpressions(
          uri_expressions, data_query, metric_queries));
      // iterate over each of the parsed metric queries and store it in the
      // TSQuery list so that we fetch the data for them.
      for (final String mq: metric_queries) {
        parseMTypeSubQuery(mq, data_query);
      }
    }
  } else {
    if (LOG.isDebugEnabled()) {
      LOG.debug("Received a request with an expression but at the "
          + "wrong endpoint: " + query);
    }
  }
  
  if (data_query.getQueries() == null || data_query.getQueries().size() < 1) {
    throw new BadRequestException("Missing sub queries");
  }

  // Filter out duplicate queries
  Set<TSSubQuery> query_set = new LinkedHashSet<TSSubQuery>(data_query.getQueries());
  data_query.getQueries().clear();
  data_query.getQueries().addAll(query_set);

  return data_query;
}
```


这个函数主要完成一个逻辑，解析Tsid或者m参数的查询，主要是下面两行函数：



```

// handle tsuid queries first
  if (query.hasQueryStringParam("tsuid")) {
    final List<String> tsuids = query.getQueryStringParams("tsuid");     
    for (String q : tsuids) {
      parseTsuidTypeSubQuery(q, data_query);
    }
  }

  if (query.hasQueryStringParam("m")) {
    final List<String> legacy_queries = query.getQueryStringParams("m");      
    for (String q : legacy_queries) {
      parseMTypeSubQuery(q, data_query);
    }
  }

```
# Scanner的一个很好的例子：

加载指定时间段内的Annotation



net.opentsdb.meta.Annotation

```java
public static Deferred<List<Annotation>> getGlobalAnnotations(final TSDB tsdb, 
      final long start_time, final long end_time)


数据表里面qualifer如果是以\01开头，就是一个Annotation。通过列名来判断
```